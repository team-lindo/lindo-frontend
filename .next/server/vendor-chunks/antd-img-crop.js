"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/antd-img-crop";
exports.ids = ["vendor-chunks/antd-img-crop"];
exports.modules = {

/***/ "./node_modules/antd-img-crop/dist/antd-img-crop.cjs.js":
/*!**************************************************************!*\
  !*** ./node_modules/antd-img-crop/dist/antd-img-crop.cjs.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar tslib = __webpack_require__(/*! tslib */ \"./node_modules/antd-img-crop/node_modules/tslib/tslib.es6.mjs\");\nvar jsxRuntime = __webpack_require__(/*! react/jsx-runtime */ \"react/jsx-runtime\");\nvar AntModal = __webpack_require__(/*! antd/lib/modal */ \"./node_modules/antd/lib/modal/index.js\");\nvar AntUpload = __webpack_require__(/*! antd/lib/upload */ \"./node_modules/antd/lib/upload/index.js\");\nvar react = __webpack_require__(/*! react */ \"react\");\nvar AntButton = __webpack_require__(/*! antd/lib/button */ \"./node_modules/antd/lib/button/index.js\");\nvar AntSlider = __webpack_require__(/*! antd/lib/slider */ \"./node_modules/antd/lib/slider/index.js\");\nvar Cropper = __webpack_require__(/*! react-easy-crop */ \"react-easy-crop\");\nconst PREFIX = \"img-crop\";\nconst ZOOM_INITIAL = 1;\nconst ZOOM_STEP = 0.1;\nconst ROTATION_INITIAL = 0;\nconst ROTATION_MIN = -180;\nconst ROTATION_MAX = 180;\nconst ROTATION_STEP = 1;\nconst ASPECT_STEP = 0.01;\nconst EasyCrop = react.forwardRef((props, ref)=>{\n    const { cropperRef, zoomSlider, rotationSlider, aspectSlider, showReset, resetBtnText, modalImage, aspect: ASPECT_INITIAL, minZoom, maxZoom, minAspect, maxAspect, cropShape, showGrid, cropperProps } = props;\n    const [zoom, setZoom] = react.useState(ZOOM_INITIAL);\n    const [rotation, setRotation] = react.useState(ROTATION_INITIAL);\n    const [aspect, setAspect] = react.useState(ASPECT_INITIAL);\n    const isResetActive = zoom !== ZOOM_INITIAL || rotation !== ROTATION_INITIAL || aspect !== ASPECT_INITIAL;\n    const onReset = ()=>{\n        setZoom(ZOOM_INITIAL);\n        setRotation(ROTATION_INITIAL);\n        setAspect(ASPECT_INITIAL);\n    };\n    const [crop, onCropChange] = react.useState({\n        x: 0,\n        y: 0\n    });\n    const cropPixelsRef = react.useRef({\n        width: 0,\n        height: 0,\n        x: 0,\n        y: 0\n    });\n    const onCropComplete = react.useCallback((_, croppedAreaPixels)=>{\n        cropPixelsRef.current = croppedAreaPixels;\n    }, []);\n    react.useImperativeHandle(ref, ()=>({\n            rotation,\n            cropPixelsRef,\n            onReset\n        }));\n    const wrapperClass = \"[display:flex] [align-items:center] [width:60%] [margin-inline:auto]\";\n    const buttonClass = \"[display:flex] [align-items:center] [justify-content:center] [height:32px] [width:32px] [background:transparent] [border:0] [font-family:inherit] [font-size:18px] [cursor:pointer] disabled:[opacity:20%] disabled:[cursor:default]\";\n    const sliderClass = \"[flex:1]\";\n    return jsxRuntime.jsxs(jsxRuntime.Fragment, {\n        children: [\n            jsxRuntime.jsx(Cropper, Object.assign({}, cropperProps, {\n                ref: cropperRef,\n                image: modalImage,\n                crop: crop,\n                //\n                zoom: zoom,\n                rotation: rotation,\n                aspect: aspect,\n                minZoom: minZoom,\n                maxZoom: maxZoom,\n                zoomWithScroll: zoomSlider,\n                //\n                cropShape: cropShape,\n                showGrid: showGrid,\n                onCropChange: onCropChange,\n                onZoomChange: setZoom,\n                onRotationChange: setRotation,\n                onCropComplete: onCropComplete,\n                classes: {\n                    containerClassName: `${PREFIX}-container ![position:relative] [width:100%] [height:40vh] [&~section:first-of-type]:[margin-top:16px] [&~section:last-of-type]:[margin-bottom:16px]`,\n                    mediaClassName: `${PREFIX}-media`\n                }\n            })),\n            zoomSlider && jsxRuntime.jsxs(\"section\", {\n                className: `${PREFIX}-control ${PREFIX}-control-zoom ${wrapperClass}`,\n                children: [\n                    jsxRuntime.jsx(\"button\", {\n                        className: buttonClass,\n                        onClick: ()=>setZoom(+(zoom - ZOOM_STEP).toFixed(1)),\n                        disabled: zoom - ZOOM_STEP < minZoom,\n                        children: \"－\"\n                    }),\n                    jsxRuntime.jsx(AntSlider, {\n                        className: sliderClass,\n                        min: minZoom,\n                        max: maxZoom,\n                        step: ZOOM_STEP,\n                        value: zoom,\n                        onChange: setZoom\n                    }),\n                    jsxRuntime.jsx(\"button\", {\n                        className: buttonClass,\n                        onClick: ()=>setZoom(+(zoom + ZOOM_STEP).toFixed(1)),\n                        disabled: zoom + ZOOM_STEP > maxZoom,\n                        children: \"＋\"\n                    })\n                ]\n            }),\n            rotationSlider && jsxRuntime.jsxs(\"section\", {\n                className: `${PREFIX}-control ${PREFIX}-control-rotation ${wrapperClass}`,\n                children: [\n                    jsxRuntime.jsx(\"button\", {\n                        className: `${buttonClass} [font-size:16px]`,\n                        onClick: ()=>setRotation(rotation - ROTATION_STEP),\n                        disabled: rotation === ROTATION_MIN,\n                        children: \"↺\"\n                    }),\n                    jsxRuntime.jsx(AntSlider, {\n                        className: sliderClass,\n                        min: ROTATION_MIN,\n                        max: ROTATION_MAX,\n                        step: ROTATION_STEP,\n                        value: rotation,\n                        onChange: setRotation\n                    }),\n                    jsxRuntime.jsx(\"button\", {\n                        className: `${buttonClass} [font-size:16px]`,\n                        onClick: ()=>setRotation(rotation + ROTATION_STEP),\n                        disabled: rotation === ROTATION_MAX,\n                        children: \"↻\"\n                    })\n                ]\n            }),\n            aspectSlider && jsxRuntime.jsxs(\"section\", {\n                className: `${PREFIX}-control ${PREFIX}-control-aspect ${wrapperClass}`,\n                children: [\n                    jsxRuntime.jsx(\"button\", {\n                        className: buttonClass,\n                        onClick: ()=>setAspect(+(aspect - ASPECT_STEP).toFixed(2)),\n                        disabled: aspect - ASPECT_STEP < minAspect,\n                        children: \"↕\"\n                    }),\n                    jsxRuntime.jsx(AntSlider, {\n                        className: sliderClass,\n                        min: minAspect,\n                        max: maxAspect,\n                        step: ASPECT_STEP,\n                        value: aspect,\n                        onChange: setAspect\n                    }),\n                    jsxRuntime.jsx(\"button\", {\n                        className: buttonClass,\n                        onClick: ()=>setAspect(+(aspect + ASPECT_STEP).toFixed(2)),\n                        disabled: aspect + ASPECT_STEP > maxAspect,\n                        children: \"↔\"\n                    })\n                ]\n            }),\n            showReset && (zoomSlider || rotationSlider || aspectSlider) && jsxRuntime.jsx(AntButton, {\n                className: \"[bottom:20px] [position:absolute]\",\n                style: isResetActive ? {} : {\n                    opacity: 0.3,\n                    pointerEvents: \"none\"\n                },\n                onClick: onReset,\n                children: resetBtnText\n            })\n        ]\n    });\n});\nvar EasyCrop$1 = react.memo(EasyCrop);\nfunction styleInject(css, ref) {\n    if (ref === void 0) ref = {};\n    var insertAt = ref.insertAt;\n    if (typeof document === \"undefined\") {\n        return;\n    }\n    var head = document.head || document.getElementsByTagName(\"head\")[0];\n    var style = document.createElement(\"style\");\n    style.type = \"text/css\";\n    if (insertAt === \"top\") {\n        if (head.firstChild) {\n            head.insertBefore(style, head.firstChild);\n        } else {\n            head.appendChild(style);\n        }\n    } else {\n        head.appendChild(style);\n    }\n    if (style.styleSheet) {\n        style.styleSheet.cssText = css;\n    } else {\n        style.appendChild(document.createTextNode(css));\n    }\n}\nvar css_248z = \".\\\\[align-items\\\\:center\\\\]{align-items:center}.\\\\[background\\\\:transparent\\\\]{background:transparent}.\\\\[border\\\\:0\\\\]{border:0}.\\\\[bottom\\\\:20px\\\\]{bottom:20px}.\\\\[cursor\\\\:pointer\\\\]{cursor:pointer}.\\\\[display\\\\:flex\\\\]{display:flex}.\\\\[flex\\\\:1\\\\]{flex:1}.\\\\[font-family\\\\:inherit\\\\]{font-family:inherit}.\\\\[font-size\\\\:16px\\\\]{font-size:16px}.\\\\[font-size\\\\:18px\\\\]{font-size:18px}.\\\\[height\\\\:32px\\\\]{height:32px}.\\\\[height\\\\:40vh\\\\]{height:40vh}.\\\\[justify-content\\\\:center\\\\]{justify-content:center}.\\\\[margin-inline\\\\:auto\\\\]{margin-inline:auto}.\\\\[position\\\\:absolute\\\\]{position:absolute}.\\\\!\\\\[position\\\\:relative\\\\]{position:relative!important}.\\\\[width\\\\:100\\\\%\\\\]{width:100%}.\\\\[width\\\\:32px\\\\]{width:32px}.\\\\[width\\\\:60\\\\%\\\\]{width:60%}.disabled\\\\:\\\\[cursor\\\\:default\\\\]:disabled{cursor:default}.disabled\\\\:\\\\[opacity\\\\:20\\\\%\\\\]:disabled{opacity:20%}.\\\\[\\\\&\\\\~section\\\\:first-of-type\\\\]\\\\:\\\\[margin-top\\\\:16px\\\\]~section:first-of-type{margin-top:16px}.\\\\[\\\\&\\\\~section\\\\:last-of-type\\\\]\\\\:\\\\[margin-bottom\\\\:16px\\\\]~section:last-of-type{margin-bottom:16px}\";\nstyleInject(css_248z, {\n    \"insertAt\": \"top\"\n});\nconst ImgCrop = react.forwardRef((props, cropperRef)=>{\n    const { quality = 0.4, fillColor = \"white\", zoomSlider = true, rotationSlider = false, aspectSlider = false, showReset = false, resetText, aspect = 1, minZoom = 1, maxZoom = 3, minAspect = 0.5, maxAspect = 2, cropShape = \"rect\", showGrid = false, cropperProps, modalClassName, modalTitle, modalWidth, modalOk, modalCancel, onModalOk, onModalCancel, modalProps, beforeCrop, children } = props;\n    const cb = react.useRef({});\n    cb.current.onModalOk = onModalOk;\n    cb.current.onModalCancel = onModalCancel;\n    cb.current.beforeCrop = beforeCrop;\n    /**\n     * crop\n     */ const easyCropRef = react.useRef(null);\n    const getCropCanvas = react.useCallback((target)=>{\n        var _a;\n        const canvas = document.createElement(\"canvas\");\n        const ctx = canvas.getContext(\"2d\");\n        const context = ((_a = target === null || target === void 0 ? void 0 : target.getRootNode) === null || _a === void 0 ? void 0 : _a.call(target)) || document;\n        const imgSource = context.querySelector(`.${PREFIX}-media`);\n        const { width: cropWidth, height: cropHeight, x: cropX, y: cropY } = easyCropRef.current.cropPixelsRef.current;\n        if (rotationSlider && easyCropRef.current.rotation !== ROTATION_INITIAL) {\n            const { naturalWidth: imgWidth, naturalHeight: imgHeight } = imgSource;\n            const angle = easyCropRef.current.rotation * (Math.PI / 180);\n            // get container for rotated image\n            const sine = Math.abs(Math.sin(angle));\n            const cosine = Math.abs(Math.cos(angle));\n            const squareWidth = imgWidth * cosine + imgHeight * sine;\n            const squareHeight = imgHeight * cosine + imgWidth * sine;\n            canvas.width = squareWidth;\n            canvas.height = squareHeight;\n            ctx.fillStyle = fillColor;\n            ctx.fillRect(0, 0, squareWidth, squareHeight);\n            // rotate container\n            const squareHalfWidth = squareWidth / 2;\n            const squareHalfHeight = squareHeight / 2;\n            ctx.translate(squareHalfWidth, squareHalfHeight);\n            ctx.rotate(angle);\n            ctx.translate(-squareHalfWidth, -squareHalfHeight);\n            // draw rotated image\n            const imgX = (squareWidth - imgWidth) / 2;\n            const imgY = (squareHeight - imgHeight) / 2;\n            ctx.drawImage(imgSource, 0, 0, imgWidth, imgHeight, imgX, imgY, imgWidth, imgHeight);\n            // crop rotated image\n            const imgData = ctx.getImageData(0, 0, squareWidth, squareHeight);\n            canvas.width = cropWidth;\n            canvas.height = cropHeight;\n            ctx.putImageData(imgData, -cropX, -cropY);\n        } else {\n            canvas.width = cropWidth;\n            canvas.height = cropHeight;\n            ctx.fillStyle = fillColor;\n            ctx.fillRect(0, 0, cropWidth, cropHeight);\n            ctx.drawImage(imgSource, cropX, cropY, cropWidth, cropHeight, 0, 0, cropWidth, cropHeight);\n        }\n        return canvas;\n    }, [\n        fillColor,\n        rotationSlider\n    ]);\n    /**\n     * upload\n     */ const [modalImage, setModalImage] = react.useState(\"\");\n    const onCancel = react.useRef();\n    const onOk = react.useRef();\n    const runBeforeUpload = react.useCallback((_a)=>tslib.__awaiter(void 0, [\n            _a\n        ], void 0, function*({ beforeUpload, file, resolve, reject }) {\n            const rawFile = file;\n            if (typeof beforeUpload !== \"function\") {\n                resolve(rawFile);\n                return;\n            }\n            try {\n                // https://ant.design/components/upload-cn#api\n                // https://github.com/ant-design/ant-design/blob/master/components/upload/Upload.tsx#L152-L178\n                const result = yield beforeUpload(file, [\n                    file\n                ]);\n                if (result === false) {\n                    resolve(false);\n                } else {\n                    resolve(result !== true && result || rawFile);\n                }\n            } catch (err) {\n                reject(err);\n            }\n        }), []);\n    const getNewBeforeUpload = react.useCallback((beforeUpload)=>{\n        return (file, fileList)=>{\n            return new Promise((resolve, reject)=>tslib.__awaiter(void 0, void 0, void 0, function*() {\n                    let processedFile = file;\n                    if (typeof cb.current.beforeCrop === \"function\") {\n                        try {\n                            const result = yield cb.current.beforeCrop(file, fileList);\n                            if (result === false) {\n                                return runBeforeUpload({\n                                    beforeUpload,\n                                    file,\n                                    resolve,\n                                    reject\n                                }); // not open modal\n                            }\n                            if (result !== true) {\n                                processedFile = result || file; // will open modal\n                            }\n                        } catch (err) {\n                            return runBeforeUpload({\n                                beforeUpload,\n                                file,\n                                resolve,\n                                reject\n                            }); // not open modal\n                        }\n                    }\n                    // read file\n                    const reader = new FileReader();\n                    reader.addEventListener(\"load\", ()=>{\n                        if (typeof reader.result === \"string\") {\n                            setModalImage(reader.result); // open modal\n                        }\n                    });\n                    reader.readAsDataURL(processedFile);\n                    // on modal cancel\n                    onCancel.current = ()=>{\n                        var _a, _b;\n                        setModalImage(\"\");\n                        easyCropRef.current.onReset();\n                        let hasResolveCalled = false;\n                        (_b = (_a = cb.current).onModalCancel) === null || _b === void 0 ? void 0 : _b.call(_a, (LIST_IGNORE)=>{\n                            resolve(LIST_IGNORE);\n                            hasResolveCalled = true;\n                        });\n                        if (!hasResolveCalled) {\n                            resolve(AntUpload.LIST_IGNORE);\n                        }\n                    };\n                    // on modal confirm\n                    onOk.current = (event)=>tslib.__awaiter(void 0, void 0, void 0, function*() {\n                            setModalImage(\"\");\n                            easyCropRef.current.onReset();\n                            const canvas = getCropCanvas(event.target);\n                            const { type, name, uid } = processedFile;\n                            canvas.toBlob((blob)=>tslib.__awaiter(void 0, void 0, void 0, function*() {\n                                    const newFile = new File([\n                                        blob\n                                    ], name, {\n                                        type\n                                    });\n                                    Object.assign(newFile, {\n                                        uid\n                                    });\n                                    runBeforeUpload({\n                                        beforeUpload,\n                                        file: newFile,\n                                        resolve: (file)=>{\n                                            var _a, _b;\n                                            resolve(file);\n                                            (_b = (_a = cb.current).onModalOk) === null || _b === void 0 ? void 0 : _b.call(_a, file);\n                                        },\n                                        reject: (err)=>{\n                                            var _a, _b;\n                                            reject(err);\n                                            (_b = (_a = cb.current).onModalOk) === null || _b === void 0 ? void 0 : _b.call(_a, err);\n                                        }\n                                    });\n                                }), type, quality);\n                        });\n                }));\n        };\n    }, [\n        getCropCanvas,\n        quality,\n        runBeforeUpload\n    ]);\n    const getNewUpload = react.useCallback((children)=>{\n        const upload = Array.isArray(children) ? children[0] : children;\n        const _a = upload.props, { beforeUpload, accept } = _a, restUploadProps = tslib.__rest(_a, [\n            \"beforeUpload\",\n            \"accept\"\n        ]);\n        return Object.assign(Object.assign({}, upload), {\n            props: Object.assign(Object.assign({}, restUploadProps), {\n                accept: accept || \"image/*\",\n                beforeUpload: getNewBeforeUpload(beforeUpload)\n            })\n        });\n    }, [\n        getNewBeforeUpload\n    ]);\n    /**\n     * modal\n     */ const modalBaseProps = react.useMemo(()=>{\n        const obj = {};\n        if (modalWidth !== undefined) obj.width = modalWidth;\n        if (modalOk !== undefined) obj.okText = modalOk;\n        if (modalCancel !== undefined) obj.cancelText = modalCancel;\n        return obj;\n    }, [\n        modalCancel,\n        modalOk,\n        modalWidth\n    ]);\n    const wrapClassName = `${PREFIX}-modal${modalClassName ? ` ${modalClassName}` : \"\"}`;\n    const lang =  true ? \"\" : 0;\n    const isCN = lang === \"zh-CN\";\n    const title = modalTitle || (isCN ? \"编辑图片\" : \"Edit image\");\n    const resetBtnText = resetText || (isCN ? \"重置\" : \"Reset\");\n    return jsxRuntime.jsxs(jsxRuntime.Fragment, {\n        children: [\n            getNewUpload(children),\n            modalImage && jsxRuntime.jsx(AntModal, Object.assign({}, modalProps, modalBaseProps, {\n                open: true,\n                title: title,\n                onCancel: onCancel.current,\n                onOk: onOk.current,\n                wrapClassName: wrapClassName,\n                maskClosable: false,\n                destroyOnClose: true,\n                children: jsxRuntime.jsx(EasyCrop$1, {\n                    ref: easyCropRef,\n                    cropperRef: cropperRef,\n                    zoomSlider: zoomSlider,\n                    rotationSlider: rotationSlider,\n                    aspectSlider: aspectSlider,\n                    showReset: showReset,\n                    resetBtnText: resetBtnText,\n                    modalImage: modalImage,\n                    aspect: aspect,\n                    minZoom: minZoom,\n                    maxZoom: maxZoom,\n                    minAspect: minAspect,\n                    maxAspect: maxAspect,\n                    cropShape: cropShape,\n                    showGrid: showGrid,\n                    cropperProps: cropperProps\n                })\n            }))\n        ]\n    });\n});\nmodule.exports = ImgCrop;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYW50ZC1pbWctY3JvcC9kaXN0L2FudGQtaW1nLWNyb3AuY2pzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUM7QUFDcEIsSUFBSUMsYUFBYUQsbUJBQU9BLENBQUM7QUFDekIsSUFBSUUsV0FBV0YsbUJBQU9BLENBQUM7QUFDdkIsSUFBSUcsWUFBWUgsbUJBQU9BLENBQUM7QUFDeEIsSUFBSUksUUFBUUosbUJBQU9BLENBQUM7QUFDcEIsSUFBSUssWUFBWUwsbUJBQU9BLENBQUM7QUFDeEIsSUFBSU0sWUFBWU4sbUJBQU9BLENBQUM7QUFDeEIsSUFBSU8sVUFBVVAsbUJBQU9BLENBQUM7QUFFdEIsTUFBTVEsU0FBUztBQUNmLE1BQU1DLGVBQWU7QUFDckIsTUFBTUMsWUFBWTtBQUNsQixNQUFNQyxtQkFBbUI7QUFDekIsTUFBTUMsZUFBZSxDQUFDO0FBQ3RCLE1BQU1DLGVBQWU7QUFDckIsTUFBTUMsZ0JBQWdCO0FBQ3RCLE1BQU1DLGNBQWM7QUFFcEIsTUFBTUMsV0FBV1osTUFBTWEsVUFBVSxDQUFDLENBQUNDLE9BQU9DO0lBQ3RDLE1BQU0sRUFBRUMsVUFBVSxFQUFFQyxVQUFVLEVBQUVDLGNBQWMsRUFBRUMsWUFBWSxFQUFFQyxTQUFTLEVBQUVDLFlBQVksRUFBRUMsVUFBVSxFQUFFQyxRQUFRQyxjQUFjLEVBQUVDLE9BQU8sRUFBRUMsT0FBTyxFQUFFQyxTQUFTLEVBQUVDLFNBQVMsRUFBRUMsU0FBUyxFQUFFQyxRQUFRLEVBQUVDLFlBQVksRUFBRyxHQUFHakI7SUFDMU0sTUFBTSxDQUFDa0IsTUFBTUMsUUFBUSxHQUFHakMsTUFBTWtDLFFBQVEsQ0FBQzdCO0lBQ3ZDLE1BQU0sQ0FBQzhCLFVBQVVDLFlBQVksR0FBR3BDLE1BQU1rQyxRQUFRLENBQUMzQjtJQUMvQyxNQUFNLENBQUNnQixRQUFRYyxVQUFVLEdBQUdyQyxNQUFNa0MsUUFBUSxDQUFDVjtJQUMzQyxNQUFNYyxnQkFBZ0JO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RzlHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3Qtbm9kZWJpcmQtZnJvbnQvLi9ub2RlX21vZHVsZXMvYW50ZC1pbWctY3JvcC9kaXN0L2FudGQtaW1nLWNyb3AuY2pzLmpzPzRkZDkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdHNsaWIgPSByZXF1aXJlKCd0c2xpYicpO1xudmFyIGpzeFJ1bnRpbWUgPSByZXF1aXJlKCdyZWFjdC9qc3gtcnVudGltZScpO1xudmFyIEFudE1vZGFsID0gcmVxdWlyZSgnYW50ZC9saWIvbW9kYWwnKTtcbnZhciBBbnRVcGxvYWQgPSByZXF1aXJlKCdhbnRkL2xpYi91cGxvYWQnKTtcbnZhciByZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgQW50QnV0dG9uID0gcmVxdWlyZSgnYW50ZC9saWIvYnV0dG9uJyk7XG52YXIgQW50U2xpZGVyID0gcmVxdWlyZSgnYW50ZC9saWIvc2xpZGVyJyk7XG52YXIgQ3JvcHBlciA9IHJlcXVpcmUoJ3JlYWN0LWVhc3ktY3JvcCcpO1xuXG5jb25zdCBQUkVGSVggPSAnaW1nLWNyb3AnO1xuY29uc3QgWk9PTV9JTklUSUFMID0gMTtcbmNvbnN0IFpPT01fU1RFUCA9IDAuMTtcbmNvbnN0IFJPVEFUSU9OX0lOSVRJQUwgPSAwO1xuY29uc3QgUk9UQVRJT05fTUlOID0gLTE4MDtcbmNvbnN0IFJPVEFUSU9OX01BWCA9IDE4MDtcbmNvbnN0IFJPVEFUSU9OX1NURVAgPSAxO1xuY29uc3QgQVNQRUNUX1NURVAgPSAwLjAxO1xuXG5jb25zdCBFYXN5Q3JvcCA9IHJlYWN0LmZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IHtcbiAgICBjb25zdCB7IGNyb3BwZXJSZWYsIHpvb21TbGlkZXIsIHJvdGF0aW9uU2xpZGVyLCBhc3BlY3RTbGlkZXIsIHNob3dSZXNldCwgcmVzZXRCdG5UZXh0LCBtb2RhbEltYWdlLCBhc3BlY3Q6IEFTUEVDVF9JTklUSUFMLCBtaW5ab29tLCBtYXhab29tLCBtaW5Bc3BlY3QsIG1heEFzcGVjdCwgY3JvcFNoYXBlLCBzaG93R3JpZCwgY3JvcHBlclByb3BzLCB9ID0gcHJvcHM7XG4gICAgY29uc3QgW3pvb20sIHNldFpvb21dID0gcmVhY3QudXNlU3RhdGUoWk9PTV9JTklUSUFMKTtcbiAgICBjb25zdCBbcm90YXRpb24sIHNldFJvdGF0aW9uXSA9IHJlYWN0LnVzZVN0YXRlKFJPVEFUSU9OX0lOSVRJQUwpO1xuICAgIGNvbnN0IFthc3BlY3QsIHNldEFzcGVjdF0gPSByZWFjdC51c2VTdGF0ZShBU1BFQ1RfSU5JVElBTCk7XG4gICAgY29uc3QgaXNSZXNldEFjdGl2ZSA9IHpvb20gIT09IFpPT01fSU5JVElBTCB8fFxuICAgICAgICByb3RhdGlvbiAhPT0gUk9UQVRJT05fSU5JVElBTCB8fFxuICAgICAgICBhc3BlY3QgIT09IEFTUEVDVF9JTklUSUFMO1xuICAgIGNvbnN0IG9uUmVzZXQgPSAoKSA9PiB7XG4gICAgICAgIHNldFpvb20oWk9PTV9JTklUSUFMKTtcbiAgICAgICAgc2V0Um90YXRpb24oUk9UQVRJT05fSU5JVElBTCk7XG4gICAgICAgIHNldEFzcGVjdChBU1BFQ1RfSU5JVElBTCk7XG4gICAgfTtcbiAgICBjb25zdCBbY3JvcCwgb25Dcm9wQ2hhbmdlXSA9IHJlYWN0LnVzZVN0YXRlKHsgeDogMCwgeTogMCB9KTtcbiAgICBjb25zdCBjcm9wUGl4ZWxzUmVmID0gcmVhY3QudXNlUmVmKHsgd2lkdGg6IDAsIGhlaWdodDogMCwgeDogMCwgeTogMCB9KTtcbiAgICBjb25zdCBvbkNyb3BDb21wbGV0ZSA9IHJlYWN0LnVzZUNhbGxiYWNrKChfLCBjcm9wcGVkQXJlYVBpeGVscykgPT4ge1xuICAgICAgICBjcm9wUGl4ZWxzUmVmLmN1cnJlbnQgPSBjcm9wcGVkQXJlYVBpeGVscztcbiAgICB9LCBbXSk7XG4gICAgcmVhY3QudXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsICgpID0+ICh7XG4gICAgICAgIHJvdGF0aW9uLFxuICAgICAgICBjcm9wUGl4ZWxzUmVmLFxuICAgICAgICBvblJlc2V0LFxuICAgIH0pKTtcbiAgICBjb25zdCB3cmFwcGVyQ2xhc3MgPSAnW2Rpc3BsYXk6ZmxleF0gW2FsaWduLWl0ZW1zOmNlbnRlcl0gW3dpZHRoOjYwJV0gW21hcmdpbi1pbmxpbmU6YXV0b10nO1xuICAgIGNvbnN0IGJ1dHRvbkNsYXNzID0gJ1tkaXNwbGF5OmZsZXhdIFthbGlnbi1pdGVtczpjZW50ZXJdIFtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyXSBbaGVpZ2h0OjMycHhdIFt3aWR0aDozMnB4XSBbYmFja2dyb3VuZDp0cmFuc3BhcmVudF0gW2JvcmRlcjowXSBbZm9udC1mYW1pbHk6aW5oZXJpdF0gW2ZvbnQtc2l6ZToxOHB4XSBbY3Vyc29yOnBvaW50ZXJdIGRpc2FibGVkOltvcGFjaXR5OjIwJV0gZGlzYWJsZWQ6W2N1cnNvcjpkZWZhdWx0XSc7XG4gICAgY29uc3Qgc2xpZGVyQ2xhc3MgPSAnW2ZsZXg6MV0nO1xuICAgIHJldHVybiAoanN4UnVudGltZS5qc3hzKGpzeFJ1bnRpbWUuRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtqc3hSdW50aW1lLmpzeChDcm9wcGVyLCBPYmplY3QuYXNzaWduKHt9LCBjcm9wcGVyUHJvcHMsIHsgcmVmOiBjcm9wcGVyUmVmLCBpbWFnZTogbW9kYWxJbWFnZSwgY3JvcDogY3JvcCwgXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICB6b29tOiB6b29tLCByb3RhdGlvbjogcm90YXRpb24sIGFzcGVjdDogYXNwZWN0LCBtaW5ab29tOiBtaW5ab29tLCBtYXhab29tOiBtYXhab29tLCB6b29tV2l0aFNjcm9sbDogem9vbVNsaWRlciwgXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICBjcm9wU2hhcGU6IGNyb3BTaGFwZSwgc2hvd0dyaWQ6IHNob3dHcmlkLCBvbkNyb3BDaGFuZ2U6IG9uQ3JvcENoYW5nZSwgb25ab29tQ2hhbmdlOiBzZXRab29tLCBvblJvdGF0aW9uQ2hhbmdlOiBzZXRSb3RhdGlvbiwgb25Dcm9wQ29tcGxldGU6IG9uQ3JvcENvbXBsZXRlLCBjbGFzc2VzOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lckNsYXNzTmFtZTogYCR7UFJFRklYfS1jb250YWluZXIgIVtwb3NpdGlvbjpyZWxhdGl2ZV0gW3dpZHRoOjEwMCVdIFtoZWlnaHQ6NDB2aF0gWyZ+c2VjdGlvbjpmaXJzdC1vZi10eXBlXTpbbWFyZ2luLXRvcDoxNnB4XSBbJn5zZWN0aW9uOmxhc3Qtb2YtdHlwZV06W21hcmdpbi1ib3R0b206MTZweF1gLFxuICAgICAgICAgICAgICAgICAgICBtZWRpYUNsYXNzTmFtZTogYCR7UFJFRklYfS1tZWRpYWAsXG4gICAgICAgICAgICAgICAgfSB9KSksIHpvb21TbGlkZXIgJiYgKGpzeFJ1bnRpbWUuanN4cyhcInNlY3Rpb25cIiwgeyBjbGFzc05hbWU6IGAke1BSRUZJWH0tY29udHJvbCAke1BSRUZJWH0tY29udHJvbC16b29tICR7d3JhcHBlckNsYXNzfWAsIGNoaWxkcmVuOiBbanN4UnVudGltZS5qc3goXCJidXR0b25cIiwgeyBjbGFzc05hbWU6IGJ1dHRvbkNsYXNzLCBvbkNsaWNrOiAoKSA9PiBzZXRab29tKCsoem9vbSAtIFpPT01fU1RFUCkudG9GaXhlZCgxKSksIGRpc2FibGVkOiB6b29tIC0gWk9PTV9TVEVQIDwgbWluWm9vbSwgY2hpbGRyZW46IFwiXFx1RkYwRFwiIH0pLCBqc3hSdW50aW1lLmpzeChBbnRTbGlkZXIsIHsgY2xhc3NOYW1lOiBzbGlkZXJDbGFzcywgbWluOiBtaW5ab29tLCBtYXg6IG1heFpvb20sIHN0ZXA6IFpPT01fU1RFUCwgdmFsdWU6IHpvb20sIG9uQ2hhbmdlOiBzZXRab29tIH0pLCBqc3hSdW50aW1lLmpzeChcImJ1dHRvblwiLCB7IGNsYXNzTmFtZTogYnV0dG9uQ2xhc3MsIG9uQ2xpY2s6ICgpID0+IHNldFpvb20oKyh6b29tICsgWk9PTV9TVEVQKS50b0ZpeGVkKDEpKSwgZGlzYWJsZWQ6IHpvb20gKyBaT09NX1NURVAgPiBtYXhab29tLCBjaGlsZHJlbjogXCJcXHVGRjBCXCIgfSldIH0pKSwgcm90YXRpb25TbGlkZXIgJiYgKGpzeFJ1bnRpbWUuanN4cyhcInNlY3Rpb25cIiwgeyBjbGFzc05hbWU6IGAke1BSRUZJWH0tY29udHJvbCAke1BSRUZJWH0tY29udHJvbC1yb3RhdGlvbiAke3dyYXBwZXJDbGFzc31gLCBjaGlsZHJlbjogW2pzeFJ1bnRpbWUuanN4KFwiYnV0dG9uXCIsIHsgY2xhc3NOYW1lOiBgJHtidXR0b25DbGFzc30gW2ZvbnQtc2l6ZToxNnB4XWAsIG9uQ2xpY2s6ICgpID0+IHNldFJvdGF0aW9uKHJvdGF0aW9uIC0gUk9UQVRJT05fU1RFUCksIGRpc2FibGVkOiByb3RhdGlvbiA9PT0gUk9UQVRJT05fTUlOLCBjaGlsZHJlbjogXCJcXHUyMUJBXCIgfSksIGpzeFJ1bnRpbWUuanN4KEFudFNsaWRlciwgeyBjbGFzc05hbWU6IHNsaWRlckNsYXNzLCBtaW46IFJPVEFUSU9OX01JTiwgbWF4OiBST1RBVElPTl9NQVgsIHN0ZXA6IFJPVEFUSU9OX1NURVAsIHZhbHVlOiByb3RhdGlvbiwgb25DaGFuZ2U6IHNldFJvdGF0aW9uIH0pLCBqc3hSdW50aW1lLmpzeChcImJ1dHRvblwiLCB7IGNsYXNzTmFtZTogYCR7YnV0dG9uQ2xhc3N9IFtmb250LXNpemU6MTZweF1gLCBvbkNsaWNrOiAoKSA9PiBzZXRSb3RhdGlvbihyb3RhdGlvbiArIFJPVEFUSU9OX1NURVApLCBkaXNhYmxlZDogcm90YXRpb24gPT09IFJPVEFUSU9OX01BWCwgY2hpbGRyZW46IFwiXFx1MjFCQlwiIH0pXSB9KSksIGFzcGVjdFNsaWRlciAmJiAoanN4UnVudGltZS5qc3hzKFwic2VjdGlvblwiLCB7IGNsYXNzTmFtZTogYCR7UFJFRklYfS1jb250cm9sICR7UFJFRklYfS1jb250cm9sLWFzcGVjdCAke3dyYXBwZXJDbGFzc31gLCBjaGlsZHJlbjogW2pzeFJ1bnRpbWUuanN4KFwiYnV0dG9uXCIsIHsgY2xhc3NOYW1lOiBidXR0b25DbGFzcywgb25DbGljazogKCkgPT4gc2V0QXNwZWN0KCsoYXNwZWN0IC0gQVNQRUNUX1NURVApLnRvRml4ZWQoMikpLCBkaXNhYmxlZDogYXNwZWN0IC0gQVNQRUNUX1NURVAgPCBtaW5Bc3BlY3QsIGNoaWxkcmVuOiBcIlxcdTIxOTVcIiB9KSwganN4UnVudGltZS5qc3goQW50U2xpZGVyLCB7IGNsYXNzTmFtZTogc2xpZGVyQ2xhc3MsIG1pbjogbWluQXNwZWN0LCBtYXg6IG1heEFzcGVjdCwgc3RlcDogQVNQRUNUX1NURVAsIHZhbHVlOiBhc3BlY3QsIG9uQ2hhbmdlOiBzZXRBc3BlY3QgfSksIGpzeFJ1bnRpbWUuanN4KFwiYnV0dG9uXCIsIHsgY2xhc3NOYW1lOiBidXR0b25DbGFzcywgb25DbGljazogKCkgPT4gc2V0QXNwZWN0KCsoYXNwZWN0ICsgQVNQRUNUX1NURVApLnRvRml4ZWQoMikpLCBkaXNhYmxlZDogYXNwZWN0ICsgQVNQRUNUX1NURVAgPiBtYXhBc3BlY3QsIGNoaWxkcmVuOiBcIlxcdTIxOTRcIiB9KV0gfSkpLCBzaG93UmVzZXQgJiYgKHpvb21TbGlkZXIgfHwgcm90YXRpb25TbGlkZXIgfHwgYXNwZWN0U2xpZGVyKSAmJiAoanN4UnVudGltZS5qc3goQW50QnV0dG9uLCB7IGNsYXNzTmFtZTogXCJbYm90dG9tOjIwcHhdIFtwb3NpdGlvbjphYnNvbHV0ZV1cIiwgc3R5bGU6IGlzUmVzZXRBY3RpdmUgPyB7fSA6IHsgb3BhY2l0eTogMC4zLCBwb2ludGVyRXZlbnRzOiAnbm9uZScgfSwgb25DbGljazogb25SZXNldCwgY2hpbGRyZW46IHJlc2V0QnRuVGV4dCB9KSldIH0pKTtcbn0pO1xudmFyIEVhc3lDcm9wJDEgPSByZWFjdC5tZW1vKEVhc3lDcm9wKTtcblxuZnVuY3Rpb24gc3R5bGVJbmplY3QoY3NzLCByZWYpIHtcbiAgaWYgKCByZWYgPT09IHZvaWQgMCApIHJlZiA9IHt9O1xuICB2YXIgaW5zZXJ0QXQgPSByZWYuaW5zZXJ0QXQ7XG5cbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuOyB9XG5cbiAgdmFyIGhlYWQgPSBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gIHN0eWxlLnR5cGUgPSAndGV4dC9jc3MnO1xuXG4gIGlmIChpbnNlcnRBdCA9PT0gJ3RvcCcpIHtcbiAgICBpZiAoaGVhZC5maXJzdENoaWxkKSB7XG4gICAgICBoZWFkLmluc2VydEJlZm9yZShzdHlsZSwgaGVhZC5maXJzdENoaWxkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICB9XG5cbiAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gIH0gZWxzZSB7XG4gICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gIH1cbn1cblxudmFyIGNzc18yNDh6ID0gXCIuXFxcXFthbGlnbi1pdGVtc1xcXFw6Y2VudGVyXFxcXF17YWxpZ24taXRlbXM6Y2VudGVyfS5cXFxcW2JhY2tncm91bmRcXFxcOnRyYW5zcGFyZW50XFxcXF17YmFja2dyb3VuZDp0cmFuc3BhcmVudH0uXFxcXFtib3JkZXJcXFxcOjBcXFxcXXtib3JkZXI6MH0uXFxcXFtib3R0b21cXFxcOjIwcHhcXFxcXXtib3R0b206MjBweH0uXFxcXFtjdXJzb3JcXFxcOnBvaW50ZXJcXFxcXXtjdXJzb3I6cG9pbnRlcn0uXFxcXFtkaXNwbGF5XFxcXDpmbGV4XFxcXF17ZGlzcGxheTpmbGV4fS5cXFxcW2ZsZXhcXFxcOjFcXFxcXXtmbGV4OjF9LlxcXFxbZm9udC1mYW1pbHlcXFxcOmluaGVyaXRcXFxcXXtmb250LWZhbWlseTppbmhlcml0fS5cXFxcW2ZvbnQtc2l6ZVxcXFw6MTZweFxcXFxde2ZvbnQtc2l6ZToxNnB4fS5cXFxcW2ZvbnQtc2l6ZVxcXFw6MThweFxcXFxde2ZvbnQtc2l6ZToxOHB4fS5cXFxcW2hlaWdodFxcXFw6MzJweFxcXFxde2hlaWdodDozMnB4fS5cXFxcW2hlaWdodFxcXFw6NDB2aFxcXFxde2hlaWdodDo0MHZofS5cXFxcW2p1c3RpZnktY29udGVudFxcXFw6Y2VudGVyXFxcXF17anVzdGlmeS1jb250ZW50OmNlbnRlcn0uXFxcXFttYXJnaW4taW5saW5lXFxcXDphdXRvXFxcXF17bWFyZ2luLWlubGluZTphdXRvfS5cXFxcW3Bvc2l0aW9uXFxcXDphYnNvbHV0ZVxcXFxde3Bvc2l0aW9uOmFic29sdXRlfS5cXFxcIVxcXFxbcG9zaXRpb25cXFxcOnJlbGF0aXZlXFxcXF17cG9zaXRpb246cmVsYXRpdmUhaW1wb3J0YW50fS5cXFxcW3dpZHRoXFxcXDoxMDBcXFxcJVxcXFxde3dpZHRoOjEwMCV9LlxcXFxbd2lkdGhcXFxcOjMycHhcXFxcXXt3aWR0aDozMnB4fS5cXFxcW3dpZHRoXFxcXDo2MFxcXFwlXFxcXF17d2lkdGg6NjAlfS5kaXNhYmxlZFxcXFw6XFxcXFtjdXJzb3JcXFxcOmRlZmF1bHRcXFxcXTpkaXNhYmxlZHtjdXJzb3I6ZGVmYXVsdH0uZGlzYWJsZWRcXFxcOlxcXFxbb3BhY2l0eVxcXFw6MjBcXFxcJVxcXFxdOmRpc2FibGVke29wYWNpdHk6MjAlfS5cXFxcW1xcXFwmXFxcXH5zZWN0aW9uXFxcXDpmaXJzdC1vZi10eXBlXFxcXF1cXFxcOlxcXFxbbWFyZ2luLXRvcFxcXFw6MTZweFxcXFxdfnNlY3Rpb246Zmlyc3Qtb2YtdHlwZXttYXJnaW4tdG9wOjE2cHh9LlxcXFxbXFxcXCZcXFxcfnNlY3Rpb25cXFxcOmxhc3Qtb2YtdHlwZVxcXFxdXFxcXDpcXFxcW21hcmdpbi1ib3R0b21cXFxcOjE2cHhcXFxcXX5zZWN0aW9uOmxhc3Qtb2YtdHlwZXttYXJnaW4tYm90dG9tOjE2cHh9XCI7XG5zdHlsZUluamVjdChjc3NfMjQ4eix7XCJpbnNlcnRBdFwiOlwidG9wXCJ9KTtcblxuY29uc3QgSW1nQ3JvcCA9IHJlYWN0LmZvcndhcmRSZWYoKHByb3BzLCBjcm9wcGVyUmVmKSA9PiB7XG4gICAgY29uc3QgeyBxdWFsaXR5ID0gMC40LCBmaWxsQ29sb3IgPSAnd2hpdGUnLCB6b29tU2xpZGVyID0gdHJ1ZSwgcm90YXRpb25TbGlkZXIgPSBmYWxzZSwgYXNwZWN0U2xpZGVyID0gZmFsc2UsIHNob3dSZXNldCA9IGZhbHNlLCByZXNldFRleHQsIGFzcGVjdCA9IDEsIG1pblpvb20gPSAxLCBtYXhab29tID0gMywgbWluQXNwZWN0ID0gMC41LCBtYXhBc3BlY3QgPSAyLCBjcm9wU2hhcGUgPSAncmVjdCcsIHNob3dHcmlkID0gZmFsc2UsIGNyb3BwZXJQcm9wcywgbW9kYWxDbGFzc05hbWUsIG1vZGFsVGl0bGUsIG1vZGFsV2lkdGgsIG1vZGFsT2ssIG1vZGFsQ2FuY2VsLCBvbk1vZGFsT2ssIG9uTW9kYWxDYW5jZWwsIG1vZGFsUHJvcHMsIGJlZm9yZUNyb3AsIGNoaWxkcmVuLCB9ID0gcHJvcHM7XG4gICAgY29uc3QgY2IgPSByZWFjdC51c2VSZWYoe30pO1xuICAgIGNiLmN1cnJlbnQub25Nb2RhbE9rID0gb25Nb2RhbE9rO1xuICAgIGNiLmN1cnJlbnQub25Nb2RhbENhbmNlbCA9IG9uTW9kYWxDYW5jZWw7XG4gICAgY2IuY3VycmVudC5iZWZvcmVDcm9wID0gYmVmb3JlQ3JvcDtcbiAgICAvKipcbiAgICAgKiBjcm9wXG4gICAgICovXG4gICAgY29uc3QgZWFzeUNyb3BSZWYgPSByZWFjdC51c2VSZWYobnVsbCk7XG4gICAgY29uc3QgZ2V0Q3JvcENhbnZhcyA9IHJlYWN0LnVzZUNhbGxiYWNrKCh0YXJnZXQpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSAoKF9hID0gdGFyZ2V0ID09PSBudWxsIHx8IHRhcmdldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFyZ2V0LmdldFJvb3ROb2RlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0YXJnZXQpKSB8fCBkb2N1bWVudDtcbiAgICAgICAgY29uc3QgaW1nU291cmNlID0gY29udGV4dC5xdWVyeVNlbGVjdG9yKGAuJHtQUkVGSVh9LW1lZGlhYCk7XG4gICAgICAgIGNvbnN0IHsgd2lkdGg6IGNyb3BXaWR0aCwgaGVpZ2h0OiBjcm9wSGVpZ2h0LCB4OiBjcm9wWCwgeTogY3JvcFksIH0gPSBlYXN5Q3JvcFJlZi5jdXJyZW50LmNyb3BQaXhlbHNSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKHJvdGF0aW9uU2xpZGVyICYmXG4gICAgICAgICAgICBlYXN5Q3JvcFJlZi5jdXJyZW50LnJvdGF0aW9uICE9PSBST1RBVElPTl9JTklUSUFMKSB7XG4gICAgICAgICAgICBjb25zdCB7IG5hdHVyYWxXaWR0aDogaW1nV2lkdGgsIG5hdHVyYWxIZWlnaHQ6IGltZ0hlaWdodCB9ID0gaW1nU291cmNlO1xuICAgICAgICAgICAgY29uc3QgYW5nbGUgPSBlYXN5Q3JvcFJlZi5jdXJyZW50LnJvdGF0aW9uICogKE1hdGguUEkgLyAxODApO1xuICAgICAgICAgICAgLy8gZ2V0IGNvbnRhaW5lciBmb3Igcm90YXRlZCBpbWFnZVxuICAgICAgICAgICAgY29uc3Qgc2luZSA9IE1hdGguYWJzKE1hdGguc2luKGFuZ2xlKSk7XG4gICAgICAgICAgICBjb25zdCBjb3NpbmUgPSBNYXRoLmFicyhNYXRoLmNvcyhhbmdsZSkpO1xuICAgICAgICAgICAgY29uc3Qgc3F1YXJlV2lkdGggPSBpbWdXaWR0aCAqIGNvc2luZSArIGltZ0hlaWdodCAqIHNpbmU7XG4gICAgICAgICAgICBjb25zdCBzcXVhcmVIZWlnaHQgPSBpbWdIZWlnaHQgKiBjb3NpbmUgKyBpbWdXaWR0aCAqIHNpbmU7XG4gICAgICAgICAgICBjYW52YXMud2lkdGggPSBzcXVhcmVXaWR0aDtcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBzcXVhcmVIZWlnaHQ7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZmlsbENvbG9yO1xuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIHNxdWFyZVdpZHRoLCBzcXVhcmVIZWlnaHQpO1xuICAgICAgICAgICAgLy8gcm90YXRlIGNvbnRhaW5lclxuICAgICAgICAgICAgY29uc3Qgc3F1YXJlSGFsZldpZHRoID0gc3F1YXJlV2lkdGggLyAyO1xuICAgICAgICAgICAgY29uc3Qgc3F1YXJlSGFsZkhlaWdodCA9IHNxdWFyZUhlaWdodCAvIDI7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKHNxdWFyZUhhbGZXaWR0aCwgc3F1YXJlSGFsZkhlaWdodCk7XG4gICAgICAgICAgICBjdHgucm90YXRlKGFuZ2xlKTtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoLXNxdWFyZUhhbGZXaWR0aCwgLXNxdWFyZUhhbGZIZWlnaHQpO1xuICAgICAgICAgICAgLy8gZHJhdyByb3RhdGVkIGltYWdlXG4gICAgICAgICAgICBjb25zdCBpbWdYID0gKHNxdWFyZVdpZHRoIC0gaW1nV2lkdGgpIC8gMjtcbiAgICAgICAgICAgIGNvbnN0IGltZ1kgPSAoc3F1YXJlSGVpZ2h0IC0gaW1nSGVpZ2h0KSAvIDI7XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKGltZ1NvdXJjZSwgMCwgMCwgaW1nV2lkdGgsIGltZ0hlaWdodCwgaW1nWCwgaW1nWSwgaW1nV2lkdGgsIGltZ0hlaWdodCk7XG4gICAgICAgICAgICAvLyBjcm9wIHJvdGF0ZWQgaW1hZ2VcbiAgICAgICAgICAgIGNvbnN0IGltZ0RhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHNxdWFyZVdpZHRoLCBzcXVhcmVIZWlnaHQpO1xuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gY3JvcFdpZHRoO1xuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGNyb3BIZWlnaHQ7XG4gICAgICAgICAgICBjdHgucHV0SW1hZ2VEYXRhKGltZ0RhdGEsIC1jcm9wWCwgLWNyb3BZKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGNyb3BXaWR0aDtcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBjcm9wSGVpZ2h0O1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGZpbGxDb2xvcjtcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjcm9wV2lkdGgsIGNyb3BIZWlnaHQpO1xuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShpbWdTb3VyY2UsIGNyb3BYLCBjcm9wWSwgY3JvcFdpZHRoLCBjcm9wSGVpZ2h0LCAwLCAwLCBjcm9wV2lkdGgsIGNyb3BIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYW52YXM7XG4gICAgfSwgW2ZpbGxDb2xvciwgcm90YXRpb25TbGlkZXJdKTtcbiAgICAvKipcbiAgICAgKiB1cGxvYWRcbiAgICAgKi9cbiAgICBjb25zdCBbbW9kYWxJbWFnZSwgc2V0TW9kYWxJbWFnZV0gPSByZWFjdC51c2VTdGF0ZSgnJyk7XG4gICAgY29uc3Qgb25DYW5jZWwgPSByZWFjdC51c2VSZWYoKTtcbiAgICBjb25zdCBvbk9rID0gcmVhY3QudXNlUmVmKCk7XG4gICAgY29uc3QgcnVuQmVmb3JlVXBsb2FkID0gcmVhY3QudXNlQ2FsbGJhY2soKF9hKSA9PiB0c2xpYi5fX2F3YWl0ZXIodm9pZCAwLCBbX2FdLCB2b2lkIDAsIGZ1bmN0aW9uKiAoeyBiZWZvcmVVcGxvYWQsIGZpbGUsIHJlc29sdmUsIHJlamVjdCwgfSkge1xuICAgICAgICBjb25zdCByYXdGaWxlID0gZmlsZTtcbiAgICAgICAgaWYgKHR5cGVvZiBiZWZvcmVVcGxvYWQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJlc29sdmUocmF3RmlsZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vYW50LmRlc2lnbi9jb21wb25lbnRzL3VwbG9hZC1jbiNhcGlcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbnQtZGVzaWduL2FudC1kZXNpZ24vYmxvYi9tYXN0ZXIvY29tcG9uZW50cy91cGxvYWQvVXBsb2FkLnRzeCNMMTUyLUwxNzhcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIGJlZm9yZVVwbG9hZChmaWxlLCBbZmlsZV0pO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKHJlc3VsdCAhPT0gdHJ1ZSAmJiByZXN1bHQpIHx8IHJhd0ZpbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgfSksIFtdKTtcbiAgICBjb25zdCBnZXROZXdCZWZvcmVVcGxvYWQgPSByZWFjdC51c2VDYWxsYmFjaygoYmVmb3JlVXBsb2FkKSA9PiB7XG4gICAgICAgIHJldHVybiAoKGZpbGUsIGZpbGVMaXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gdHNsaWIuX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHByb2Nlc3NlZEZpbGUgPSBmaWxlO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2IuY3VycmVudC5iZWZvcmVDcm9wID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCBjYi5jdXJyZW50LmJlZm9yZUNyb3AoZmlsZSwgZmlsZUxpc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnVuQmVmb3JlVXBsb2FkKHsgYmVmb3JlVXBsb2FkLCBmaWxlLCByZXNvbHZlLCByZWplY3QgfSk7IC8vIG5vdCBvcGVuIG1vZGFsXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc2VkRmlsZSA9IHJlc3VsdCB8fCBmaWxlOyAvLyB3aWxsIG9wZW4gbW9kYWxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnVuQmVmb3JlVXBsb2FkKHsgYmVmb3JlVXBsb2FkLCBmaWxlLCByZXNvbHZlLCByZWplY3QgfSk7IC8vIG5vdCBvcGVuIG1vZGFsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcmVhZCBmaWxlXG4gICAgICAgICAgICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgICAgICAgICByZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZWFkZXIucmVzdWx0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0TW9kYWxJbWFnZShyZWFkZXIucmVzdWx0KTsgLy8gb3BlbiBtb2RhbFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwocHJvY2Vzc2VkRmlsZSk7XG4gICAgICAgICAgICAgICAgLy8gb24gbW9kYWwgY2FuY2VsXG4gICAgICAgICAgICAgICAgb25DYW5jZWwuY3VycmVudCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICAgICAgc2V0TW9kYWxJbWFnZSgnJyk7XG4gICAgICAgICAgICAgICAgICAgIGVhc3lDcm9wUmVmLmN1cnJlbnQub25SZXNldCgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaGFzUmVzb2x2ZUNhbGxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAoX2IgPSAoX2EgPSBjYi5jdXJyZW50KS5vbk1vZGFsQ2FuY2VsKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgKExJU1RfSUdOT1JFKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKExJU1RfSUdOT1JFKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc1Jlc29sdmVDYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNSZXNvbHZlQ2FsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKEFudFVwbG9hZC5MSVNUX0lHTk9SRSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIG9uIG1vZGFsIGNvbmZpcm1cbiAgICAgICAgICAgICAgICBvbk9rLmN1cnJlbnQgPSAoZXZlbnQpID0+IHRzbGliLl9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICBzZXRNb2RhbEltYWdlKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgZWFzeUNyb3BSZWYuY3VycmVudC5vblJlc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbnZhcyA9IGdldENyb3BDYW52YXMoZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB0eXBlLCBuYW1lLCB1aWQgfSA9IHByb2Nlc3NlZEZpbGU7XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhcy50b0Jsb2IoKGJsb2IpID0+IHRzbGliLl9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3RmlsZSA9IG5ldyBGaWxlKFtibG9iXSwgbmFtZSwgeyB0eXBlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihuZXdGaWxlLCB7IHVpZCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bkJlZm9yZVVwbG9hZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVmb3JlVXBsb2FkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGU6IG5ld0ZpbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZTogKGZpbGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKF9iID0gKF9hID0gY2IuY3VycmVudCkub25Nb2RhbE9rKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3Q6IChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChfYiA9IChfYSA9IGNiLmN1cnJlbnQpLm9uTW9kYWxPaykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KSwgdHlwZSwgcXVhbGl0eSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH0sIFtnZXRDcm9wQ2FudmFzLCBxdWFsaXR5LCBydW5CZWZvcmVVcGxvYWRdKTtcbiAgICBjb25zdCBnZXROZXdVcGxvYWQgPSByZWFjdC51c2VDYWxsYmFjaygoY2hpbGRyZW4pID0+IHtcbiAgICAgICAgY29uc3QgdXBsb2FkID0gQXJyYXkuaXNBcnJheShjaGlsZHJlbikgPyBjaGlsZHJlblswXSA6IGNoaWxkcmVuO1xuICAgICAgICBjb25zdCBfYSA9IHVwbG9hZC5wcm9wcywgeyBiZWZvcmVVcGxvYWQsIGFjY2VwdCB9ID0gX2EsIHJlc3RVcGxvYWRQcm9wcyA9IHRzbGliLl9fcmVzdChfYSwgW1wiYmVmb3JlVXBsb2FkXCIsIFwiYWNjZXB0XCJdKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdXBsb2FkKSwgeyBwcm9wczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXN0VXBsb2FkUHJvcHMpLCB7IGFjY2VwdDogYWNjZXB0IHx8ICdpbWFnZS8qJywgYmVmb3JlVXBsb2FkOiBnZXROZXdCZWZvcmVVcGxvYWQoYmVmb3JlVXBsb2FkKSB9KSB9KTtcbiAgICB9LCBbZ2V0TmV3QmVmb3JlVXBsb2FkXSk7XG4gICAgLyoqXG4gICAgICogbW9kYWxcbiAgICAgKi9cbiAgICBjb25zdCBtb2RhbEJhc2VQcm9wcyA9IHJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1vZGFsV2lkdGggIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIG9iai53aWR0aCA9IG1vZGFsV2lkdGg7XG4gICAgICAgIGlmIChtb2RhbE9rICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBvYmoub2tUZXh0ID0gbW9kYWxPaztcbiAgICAgICAgaWYgKG1vZGFsQ2FuY2VsICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBvYmouY2FuY2VsVGV4dCA9IG1vZGFsQ2FuY2VsO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sIFttb2RhbENhbmNlbCwgbW9kYWxPaywgbW9kYWxXaWR0aF0pO1xuICAgIGNvbnN0IHdyYXBDbGFzc05hbWUgPSBgJHtQUkVGSVh9LW1vZGFsJHttb2RhbENsYXNzTmFtZSA/IGAgJHttb2RhbENsYXNzTmFtZX1gIDogJyd9YDtcbiAgICBjb25zdCBsYW5nID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyAnJyA6IHdpbmRvdy5uYXZpZ2F0b3IubGFuZ3VhZ2U7XG4gICAgY29uc3QgaXNDTiA9IGxhbmcgPT09ICd6aC1DTic7XG4gICAgY29uc3QgdGl0bGUgPSBtb2RhbFRpdGxlIHx8IChpc0NOID8gJ+e8lui+keWbvueJhycgOiAnRWRpdCBpbWFnZScpO1xuICAgIGNvbnN0IHJlc2V0QnRuVGV4dCA9IHJlc2V0VGV4dCB8fCAoaXNDTiA/ICfph43nva4nIDogJ1Jlc2V0Jyk7XG4gICAgcmV0dXJuIChqc3hSdW50aW1lLmpzeHMoanN4UnVudGltZS5GcmFnbWVudCwgeyBjaGlsZHJlbjogW2dldE5ld1VwbG9hZChjaGlsZHJlbiksIG1vZGFsSW1hZ2UgJiYgKGpzeFJ1bnRpbWUuanN4KEFudE1vZGFsLCBPYmplY3QuYXNzaWduKHt9LCBtb2RhbFByb3BzLCBtb2RhbEJhc2VQcm9wcywgeyBvcGVuOiB0cnVlLCB0aXRsZTogdGl0bGUsIG9uQ2FuY2VsOiBvbkNhbmNlbC5jdXJyZW50LCBvbk9rOiBvbk9rLmN1cnJlbnQsIHdyYXBDbGFzc05hbWU6IHdyYXBDbGFzc05hbWUsIG1hc2tDbG9zYWJsZTogZmFsc2UsIGRlc3Ryb3lPbkNsb3NlOiB0cnVlLCBjaGlsZHJlbjoganN4UnVudGltZS5qc3goRWFzeUNyb3AkMSwgeyByZWY6IGVhc3lDcm9wUmVmLCBjcm9wcGVyUmVmOiBjcm9wcGVyUmVmLCB6b29tU2xpZGVyOiB6b29tU2xpZGVyLCByb3RhdGlvblNsaWRlcjogcm90YXRpb25TbGlkZXIsIGFzcGVjdFNsaWRlcjogYXNwZWN0U2xpZGVyLCBzaG93UmVzZXQ6IHNob3dSZXNldCwgcmVzZXRCdG5UZXh0OiByZXNldEJ0blRleHQsIG1vZGFsSW1hZ2U6IG1vZGFsSW1hZ2UsIGFzcGVjdDogYXNwZWN0LCBtaW5ab29tOiBtaW5ab29tLCBtYXhab29tOiBtYXhab29tLCBtaW5Bc3BlY3Q6IG1pbkFzcGVjdCwgbWF4QXNwZWN0OiBtYXhBc3BlY3QsIGNyb3BTaGFwZTogY3JvcFNoYXBlLCBzaG93R3JpZDogc2hvd0dyaWQsIGNyb3BwZXJQcm9wczogY3JvcHBlclByb3BzIH0pIH0pKSldIH0pKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEltZ0Nyb3A7XG4iXSwibmFtZXMiOlsidHNsaWIiLCJyZXF1aXJlIiwianN4UnVudGltZSIsIkFudE1vZGFsIiwiQW50VXBsb2FkIiwicmVhY3QiLCJBbnRCdXR0b24iLCJBbnRTbGlkZXIiLCJDcm9wcGVyIiwiUFJFRklYIiwiWk9PTV9JTklUSUFMIiwiWk9PTV9TVEVQIiwiUk9UQVRJT05fSU5JVElBTCIsIlJPVEFUSU9OX01JTiIsIlJPVEFUSU9OX01BWCIsIlJPVEFUSU9OX1NURVAiLCJBU1BFQ1RfU1RFUCIsIkVhc3lDcm9wIiwiZm9yd2FyZFJlZiIsInByb3BzIiwicmVmIiwiY3JvcHBlclJlZiIsInpvb21TbGlkZXIiLCJyb3RhdGlvblNsaWRlciIsImFzcGVjdFNsaWRlciIsInNob3dSZXNldCIsInJlc2V0QnRuVGV4dCIsIm1vZGFsSW1hZ2UiLCJhc3BlY3QiLCJBU1BFQ1RfSU5JVElBTCIsIm1pblpvb20iLCJtYXhab29tIiwibWluQXNwZWN0IiwibWF4QXNwZWN0IiwiY3JvcFNoYXBlIiwic2hvd0dyaWQiLCJjcm9wcGVyUHJvcHMiLCJ6b29tIiwic2V0Wm9vbSIsInVzZVN0YXRlIiwicm90YXRpb24iLCJzZXRSb3RhdGlvbiIsInNldEFzcGVjdCIsImlzUmVzZXRBY3RpdmUiLCJvblJlc2V0IiwiY3JvcCIsIm9uQ3JvcENoYW5nZSIsIngiLCJ5IiwiY3JvcFBpeGVsc1JlZiIsInVzZVJlZiIsIndpZHRoIiwiaGVpZ2h0Iiwib25Dcm9wQ29tcGxldGUiLCJ1c2VDYWxsYmFjayIsIl8iLCJjcm9wcGVkQXJlYVBpeGVscyIsImN1cnJlbnQiLCJ1c2VJbXBlcmF0aXZlSGFuZGxlIiwid3JhcHBlckNsYXNzIiwiYnV0dG9uQ2xhc3MiLCJzbGlkZXJDbGFzcyIsImpzeHMiLCJGcmFnbWVudCIsImNoaWxkcmVuIiwianN4IiwiT2JqZWN0IiwiYXNzaWduIiwiaW1hZ2UiLCJ6b29tV2l0aFNjcm9sbCIsIm9uWm9vbUNoYW5nZSIsIm9uUm90YXRpb25DaGFuZ2UiLCJjbGFzc2VzIiwiY29udGFpbmVyQ2xhc3NOYW1lIiwibWVkaWFDbGFzc05hbWUiLCJjbGFzc05hbWUiLCJvbkNsaWNrIiwidG9GaXhlZCIsImRpc2FibGVkIiwibWluIiwibWF4Iiwic3RlcCIsInZhbHVlIiwib25DaGFuZ2UiLCJzdHlsZSIsIm9wYWNpdHkiLCJwb2ludGVyRXZlbnRzIiwiRWFzeUNyb3AkMSIsIm1lbW8iLCJzdHlsZUluamVjdCIsImNzcyIsImluc2VydEF0IiwiZG9jdW1lbnQiLCJoZWFkIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJjcmVhdGVFbGVtZW50IiwidHlwZSIsImZpcnN0Q2hpbGQiLCJpbnNlcnRCZWZvcmUiLCJhcHBlbmRDaGlsZCIsInN0eWxlU2hlZXQiLCJjc3NUZXh0IiwiY3JlYXRlVGV4dE5vZGUiLCJjc3NfMjQ4eiIsIkltZ0Nyb3AiLCJxdWFsaXR5IiwiZmlsbENvbG9yIiwicmVzZXRUZXh0IiwibW9kYWxDbGFzc05hbWUiLCJtb2RhbFRpdGxlIiwibW9kYWxXaWR0aCIsIm1vZGFsT2siLCJtb2RhbENhbmNlbCIsIm9uTW9kYWxPayIsIm9uTW9kYWxDYW5jZWwiLCJtb2RhbFByb3BzIiwiYmVmb3JlQ3JvcCIsImNiIiwiZWFzeUNyb3BSZWYiLCJnZXRDcm9wQ2FudmFzIiwidGFyZ2V0IiwiX2EiLCJjYW52YXMiLCJjdHgiLCJnZXRDb250ZXh0IiwiY29udGV4dCIsImdldFJvb3ROb2RlIiwiY2FsbCIsImltZ1NvdXJjZSIsInF1ZXJ5U2VsZWN0b3IiLCJjcm9wV2lkdGgiLCJjcm9wSGVpZ2h0IiwiY3JvcFgiLCJjcm9wWSIsIm5hdHVyYWxXaWR0aCIsImltZ1dpZHRoIiwibmF0dXJhbEhlaWdodCIsImltZ0hlaWdodCIsImFuZ2xlIiwiTWF0aCIsIlBJIiwic2luZSIsImFicyIsInNpbiIsImNvc2luZSIsImNvcyIsInNxdWFyZVdpZHRoIiwic3F1YXJlSGVpZ2h0IiwiZmlsbFN0eWxlIiwiZmlsbFJlY3QiLCJzcXVhcmVIYWxmV2lkdGgiLCJzcXVhcmVIYWxmSGVpZ2h0IiwidHJhbnNsYXRlIiwicm90YXRlIiwiaW1nWCIsImltZ1kiLCJkcmF3SW1hZ2UiLCJpbWdEYXRhIiwiZ2V0SW1hZ2VEYXRhIiwicHV0SW1hZ2VEYXRhIiwic2V0TW9kYWxJbWFnZSIsIm9uQ2FuY2VsIiwib25PayIsInJ1bkJlZm9yZVVwbG9hZCIsIl9fYXdhaXRlciIsImJlZm9yZVVwbG9hZCIsImZpbGUiLCJyZXNvbHZlIiwicmVqZWN0IiwicmF3RmlsZSIsInJlc3VsdCIsImVyciIsImdldE5ld0JlZm9yZVVwbG9hZCIsImZpbGVMaXN0IiwiUHJvbWlzZSIsInByb2Nlc3NlZEZpbGUiLCJyZWFkZXIiLCJGaWxlUmVhZGVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlYWRBc0RhdGFVUkwiLCJfYiIsImhhc1Jlc29sdmVDYWxsZWQiLCJMSVNUX0lHTk9SRSIsImV2ZW50IiwibmFtZSIsInVpZCIsInRvQmxvYiIsImJsb2IiLCJuZXdGaWxlIiwiRmlsZSIsImdldE5ld1VwbG9hZCIsInVwbG9hZCIsIkFycmF5IiwiaXNBcnJheSIsImFjY2VwdCIsInJlc3RVcGxvYWRQcm9wcyIsIl9fcmVzdCIsIm1vZGFsQmFzZVByb3BzIiwidXNlTWVtbyIsIm9iaiIsInVuZGVmaW5lZCIsIm9rVGV4dCIsImNhbmNlbFRleHQiLCJ3cmFwQ2xhc3NOYW1lIiwibGFuZyIsIndpbmRvdyIsIm5hdmlnYXRvciIsImxhbmd1YWdlIiwiaXNDTiIsInRpdGxlIiwib3BlbiIsIm1hc2tDbG9zYWJsZSIsImRlc3Ryb3lPbkNsb3NlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/antd-img-crop/dist/antd-img-crop.cjs.js\n");

/***/ }),

/***/ "./node_modules/antd-img-crop/node_modules/tslib/tslib.es6.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/antd-img-crop/node_modules/tslib/tslib.es6.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __addDisposableResource: () => (/* binding */ __addDisposableResource),\n/* harmony export */   __assign: () => (/* binding */ __assign),\n/* harmony export */   __asyncDelegator: () => (/* binding */ __asyncDelegator),\n/* harmony export */   __asyncGenerator: () => (/* binding */ __asyncGenerator),\n/* harmony export */   __asyncValues: () => (/* binding */ __asyncValues),\n/* harmony export */   __await: () => (/* binding */ __await),\n/* harmony export */   __awaiter: () => (/* binding */ __awaiter),\n/* harmony export */   __classPrivateFieldGet: () => (/* binding */ __classPrivateFieldGet),\n/* harmony export */   __classPrivateFieldIn: () => (/* binding */ __classPrivateFieldIn),\n/* harmony export */   __classPrivateFieldSet: () => (/* binding */ __classPrivateFieldSet),\n/* harmony export */   __createBinding: () => (/* binding */ __createBinding),\n/* harmony export */   __decorate: () => (/* binding */ __decorate),\n/* harmony export */   __disposeResources: () => (/* binding */ __disposeResources),\n/* harmony export */   __esDecorate: () => (/* binding */ __esDecorate),\n/* harmony export */   __exportStar: () => (/* binding */ __exportStar),\n/* harmony export */   __extends: () => (/* binding */ __extends),\n/* harmony export */   __generator: () => (/* binding */ __generator),\n/* harmony export */   __importDefault: () => (/* binding */ __importDefault),\n/* harmony export */   __importStar: () => (/* binding */ __importStar),\n/* harmony export */   __makeTemplateObject: () => (/* binding */ __makeTemplateObject),\n/* harmony export */   __metadata: () => (/* binding */ __metadata),\n/* harmony export */   __param: () => (/* binding */ __param),\n/* harmony export */   __propKey: () => (/* binding */ __propKey),\n/* harmony export */   __read: () => (/* binding */ __read),\n/* harmony export */   __rest: () => (/* binding */ __rest),\n/* harmony export */   __rewriteRelativeImportExtension: () => (/* binding */ __rewriteRelativeImportExtension),\n/* harmony export */   __runInitializers: () => (/* binding */ __runInitializers),\n/* harmony export */   __setFunctionName: () => (/* binding */ __setFunctionName),\n/* harmony export */   __spread: () => (/* binding */ __spread),\n/* harmony export */   __spreadArray: () => (/* binding */ __spreadArray),\n/* harmony export */   __spreadArrays: () => (/* binding */ __spreadArrays),\n/* harmony export */   __values: () => (/* binding */ __values),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\n\nvar extendStatics = function(d, b) {\n  extendStatics = Object.setPrototypeOf ||\n      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null)\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() { this.constructor = d; }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nvar __assign = function() {\n  __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n  }\n  return __assign.apply(this, arguments);\n}\n\nfunction __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n      }\n  return t;\n}\n\nfunction __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nfunction __param(paramIndex, decorator) {\n  return function (target, key) { decorator(target, key, paramIndex); }\n}\n\nfunction __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n  var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _, done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n      var context = {};\n      for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n      for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n      context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n      var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n      if (kind === \"accessor\") {\n          if (result === void 0) continue;\n          if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n          if (_ = accept(result.get)) descriptor.get = _;\n          if (_ = accept(result.set)) descriptor.set = _;\n          if (_ = accept(result.init)) initializers.unshift(_);\n      }\n      else if (_ = accept(result)) {\n          if (kind === \"field\") initializers.unshift(_);\n          else descriptor[key] = _;\n      }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\n\nfunction __runInitializers(thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\n\nfunction __propKey(x) {\n  return typeof x === \"symbol\" ? x : \"\".concat(x);\n};\n\nfunction __setFunctionName(f, name, prefix) {\n  if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n  return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\n};\n\nfunction __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n  return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n      function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nfunction __generator(thisArg, body) {\n  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n  return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n  function verb(n) { return function (v) { return step([n, v]); }; }\n  function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n      while (g && (g = 0, op[0] && (_ = 0)), _) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n          switch (op[0]) {\n              case 0: case 1: t = op; break;\n              case 4: _.label++; return { value: op[1], done: false };\n              case 5: _.label++; y = op[1]; op = [0]; continue;\n              case 7: op = _.ops.pop(); _.trys.pop(); continue;\n              default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                  if (t[2]) _.ops.pop();\n                  _.trys.pop(); continue;\n          }\n          op = body.call(thisArg, _);\n      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\n\nvar __createBinding = Object.create ? (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n  }\n  Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nfunction __exportStar(m, o) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\n\nfunction __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n      next: function () {\n          if (o && i >= o.length) o = void 0;\n          return { value: o && o[i++], done: !o };\n      }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nfunction __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  }\n  catch (error) { e = { error: error }; }\n  finally {\n      try {\n          if (r && !r.done && (m = i[\"return\"])) m.call(i);\n      }\n      finally { if (e) throw e.error; }\n  }\n  return ar;\n}\n\n/** @deprecated */\nfunction __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n      ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\n\n/** @deprecated */\nfunction __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n          r[k] = a[j];\n  return r;\n}\n\nfunction __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n          ar[i] = from[i];\n      }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nfunction __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nfunction __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n  function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n  function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n  function fulfill(value) { resume(\"next\", value); }\n  function reject(value) { resume(\"throw\", value); }\n  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n}\n\nfunction __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n}\n\nfunction __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n}\n\nfunction __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n  return cooked;\n};\n\nvar __setModuleDefault = Object.create ? (function(o, v) {\n  Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n  o[\"default\"] = v;\n};\n\nvar ownKeys = function(o) {\n  ownKeys = Object.getOwnPropertyNames || function (o) {\n    var ar = [];\n    for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n    return ar;\n  };\n  return ownKeys(o);\n};\n\nfunction __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n  __setModuleDefault(result, mod);\n  return result;\n}\n\nfunction __importDefault(mod) {\n  return (mod && mod.__esModule) ? mod : { default: mod };\n}\n\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\n\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n}\n\nfunction __classPrivateFieldIn(state, receiver) {\n  if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\n  return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\n\nfunction __addDisposableResource(env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose, inner;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n      if (async) inner = dispose;\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\n    env.stack.push({ value: value, dispose: dispose, async: async });\n  }\n  else if (async) {\n    env.stack.push({ async: true });\n  }\n  return value;\n}\n\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n\nfunction __disposeResources(env) {\n  function fail(e) {\n    env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n    env.hasError = true;\n  }\n  var r, s = 0;\n  function next() {\n    while (r = env.stack.pop()) {\n      try {\n        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\n        if (r.dispose) {\n          var result = r.dispose.call(r.value);\n          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\n        }\n        else s |= 1;\n      }\n      catch (e) {\n        fail(e);\n      }\n    }\n    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\n    if (env.hasError) throw env.error;\n  }\n  return next();\n}\n\nfunction __rewriteRelativeImportExtension(path, preserveJsx) {\n  if (typeof path === \"string\" && /^\\.\\.?\\//.test(path)) {\n      return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {\n          return tsx ? preserveJsx ? \".jsx\" : \".js\" : d && (!ext || !cm) ? m : (d + ext + \".\" + cm.toLowerCase() + \"js\");\n      });\n  }\n  return path;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __esDecorate,\n  __runInitializers,\n  __propKey,\n  __setFunctionName,\n  __metadata,\n  __awaiter,\n  __generator,\n  __createBinding,\n  __exportStar,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn,\n  __addDisposableResource,\n  __disposeResources,\n  __rewriteRelativeImportExtension,\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYW50ZC1pbWctY3JvcC9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ2pGLHdCQUF3QjtBQUN4QjtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRU87QUFDUDtBQUNBLCtDQUErQyxPQUFPO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsY0FBYztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7O0FBRU87QUFDUCxrQ0FBa0M7QUFDbEM7O0FBRU87QUFDUCx1QkFBdUIsdUZBQXVGO0FBQzlHO0FBQ0E7QUFDQSx5R0FBeUc7QUFDekc7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBLGdFQUFnRTtBQUNoRTtBQUNBLDhDQUE4Qyx5RkFBeUY7QUFDdkksOERBQThELDJDQUEyQztBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBLGtCQUFrQix5QkFBeUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQSw0Q0FBNEMseUVBQXlFO0FBQ3JIOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQLDBCQUEwQiwrREFBK0QsaUJBQWlCO0FBQzFHO0FBQ0Esa0NBQWtDLE1BQU0sK0JBQStC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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RixTQUFTLGdCQUFnQjtBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBLGlFQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LW5vZGViaXJkLWZyb250Ly4vbm9kZV9tb2R1bGVzL2FudGQtaW1nLWNyb3Avbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5tanM/MTZhNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cblxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSwgU3VwcHJlc3NlZEVycm9yLCBTeW1ib2wsIEl0ZXJhdG9yICovXG5cbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xuICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xuICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufVxuXG5leHBvcnQgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XG4gIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XG4gICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XG4gICAgICB9XG4gICAgICByZXR1cm4gdDtcbiAgfVxuICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XG4gIHZhciB0ID0ge307XG4gIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxuICAgICAgdFtwXSA9IHNbcF07XG4gIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXG4gICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xuICAgICAgfVxuICByZXR1cm4gdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX19lc0RlY29yYXRlKGN0b3IsIGRlc2NyaXB0b3JJbiwgZGVjb3JhdG9ycywgY29udGV4dEluLCBpbml0aWFsaXplcnMsIGV4dHJhSW5pdGlhbGl6ZXJzKSB7XG4gIGZ1bmN0aW9uIGFjY2VwdChmKSB7IGlmIChmICE9PSB2b2lkIDAgJiYgdHlwZW9mIGYgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZ1bmN0aW9uIGV4cGVjdGVkXCIpOyByZXR1cm4gZjsgfVxuICB2YXIga2luZCA9IGNvbnRleHRJbi5raW5kLCBrZXkgPSBraW5kID09PSBcImdldHRlclwiID8gXCJnZXRcIiA6IGtpbmQgPT09IFwic2V0dGVyXCIgPyBcInNldFwiIDogXCJ2YWx1ZVwiO1xuICB2YXIgdGFyZ2V0ID0gIWRlc2NyaXB0b3JJbiAmJiBjdG9yID8gY29udGV4dEluW1wic3RhdGljXCJdID8gY3RvciA6IGN0b3IucHJvdG90eXBlIDogbnVsbDtcbiAgdmFyIGRlc2NyaXB0b3IgPSBkZXNjcmlwdG9ySW4gfHwgKHRhcmdldCA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBjb250ZXh0SW4ubmFtZSkgOiB7fSk7XG4gIHZhciBfLCBkb25lID0gZmFsc2U7XG4gIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgY29udGV4dCA9IHt9O1xuICAgICAgZm9yICh2YXIgcCBpbiBjb250ZXh0SW4pIGNvbnRleHRbcF0gPSBwID09PSBcImFjY2Vzc1wiID8ge30gOiBjb250ZXh0SW5bcF07XG4gICAgICBmb3IgKHZhciBwIGluIGNvbnRleHRJbi5hY2Nlc3MpIGNvbnRleHQuYWNjZXNzW3BdID0gY29udGV4dEluLmFjY2Vzc1twXTtcbiAgICAgIGNvbnRleHQuYWRkSW5pdGlhbGl6ZXIgPSBmdW5jdGlvbiAoZikgeyBpZiAoZG9uZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBhZGQgaW5pdGlhbGl6ZXJzIGFmdGVyIGRlY29yYXRpb24gaGFzIGNvbXBsZXRlZFwiKTsgZXh0cmFJbml0aWFsaXplcnMucHVzaChhY2NlcHQoZiB8fCBudWxsKSk7IH07XG4gICAgICB2YXIgcmVzdWx0ID0gKDAsIGRlY29yYXRvcnNbaV0pKGtpbmQgPT09IFwiYWNjZXNzb3JcIiA/IHsgZ2V0OiBkZXNjcmlwdG9yLmdldCwgc2V0OiBkZXNjcmlwdG9yLnNldCB9IDogZGVzY3JpcHRvcltrZXldLCBjb250ZXh0KTtcbiAgICAgIGlmIChraW5kID09PSBcImFjY2Vzc29yXCIpIHtcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIGNvbnRpbnVlO1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwgfHwgdHlwZW9mIHJlc3VsdCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuZ2V0KSkgZGVzY3JpcHRvci5nZXQgPSBfO1xuICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5zZXQpKSBkZXNjcmlwdG9yLnNldCA9IF87XG4gICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LmluaXQpKSBpbml0aWFsaXplcnMudW5zaGlmdChfKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKF8gPSBhY2NlcHQocmVzdWx0KSkge1xuICAgICAgICAgIGlmIChraW5kID09PSBcImZpZWxkXCIpIGluaXRpYWxpemVycy51bnNoaWZ0KF8pO1xuICAgICAgICAgIGVsc2UgZGVzY3JpcHRvcltrZXldID0gXztcbiAgICAgIH1cbiAgfVxuICBpZiAodGFyZ2V0KSBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBjb250ZXh0SW4ubmFtZSwgZGVzY3JpcHRvcik7XG4gIGRvbmUgPSB0cnVlO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fcnVuSW5pdGlhbGl6ZXJzKHRoaXNBcmcsIGluaXRpYWxpemVycywgdmFsdWUpIHtcbiAgdmFyIHVzZVZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDI7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaW5pdGlhbGl6ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWx1ZSA9IHVzZVZhbHVlID8gaW5pdGlhbGl6ZXJzW2ldLmNhbGwodGhpc0FyZywgdmFsdWUpIDogaW5pdGlhbGl6ZXJzW2ldLmNhbGwodGhpc0FyZyk7XG4gIH1cbiAgcmV0dXJuIHVzZVZhbHVlID8gdmFsdWUgOiB2b2lkIDA7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19wcm9wS2V5KHgpIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSBcInN5bWJvbFwiID8geCA6IFwiXCIuY29uY2F0KHgpO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fc2V0RnVuY3Rpb25OYW1lKGYsIG5hbWUsIHByZWZpeCkge1xuICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3ltYm9sXCIpIG5hbWUgPSBuYW1lLmRlc2NyaXB0aW9uID8gXCJbXCIuY29uY2F0KG5hbWUuZGVzY3JpcHRpb24sIFwiXVwiKSA6IFwiXCI7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZiwgXCJuYW1lXCIsIHsgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogcHJlZml4ID8gXCJcIi5jb25jYXQocHJlZml4LCBcIiBcIiwgbmFtZSkgOiBuYW1lIH0pO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcbiAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZyA9IE9iamVjdC5jcmVhdGUoKHR5cGVvZiBJdGVyYXRvciA9PT0gXCJmdW5jdGlvblwiID8gSXRlcmF0b3IgOiBPYmplY3QpLnByb3RvdHlwZSk7XG4gIHJldHVybiBnLm5leHQgPSB2ZXJiKDApLCBnW1widGhyb3dcIl0gPSB2ZXJiKDEpLCBnW1wicmV0dXJuXCJdID0gdmVyYigyKSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgd2hpbGUgKGcgJiYgKGcgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXykgdHJ5IHtcbiAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICB9XG59XG5cbmV4cG9ydCB2YXIgX19jcmVhdGVCaW5kaW5nID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICBvW2syXSA9IG1ba107XG59KTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fZXhwb3J0U3RhcihtLCBvKSB7XG4gIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgcCkpIF9fY3JlYXRlQmluZGluZyhvLCBtLCBwKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcbiAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgIH1cbiAgfTtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcbiAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICBpZiAoIW0pIHJldHVybiBvO1xuICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgdHJ5IHtcbiAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICB9XG4gIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICB9XG4gICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgfVxuICByZXR1cm4gYXI7XG59XG5cbi8qKiBAZGVwcmVjYXRlZCAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xuICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcbiAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcbiAgcmV0dXJuIGFyO1xufVxuXG4vKiogQGRlcHJlY2F0ZWQgKi9cbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZEFycmF5cygpIHtcbiAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XG4gIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcbiAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxuICAgICAgICAgIHJba10gPSBhW2pdO1xuICByZXR1cm4gcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXkodG8sIGZyb20sIHBhY2spIHtcbiAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xuICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXQodikge1xuICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XG4gIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG4gIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XG4gIHJldHVybiBpID0gT2JqZWN0LmNyZWF0ZSgodHlwZW9mIEFzeW5jSXRlcmF0b3IgPT09IFwiZnVuY3Rpb25cIiA/IEFzeW5jSXRlcmF0b3IgOiBPYmplY3QpLnByb3RvdHlwZSksIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiwgYXdhaXRSZXR1cm4pLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XG4gIGZ1bmN0aW9uIGF3YWl0UmV0dXJuKGYpIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUodikudGhlbihmLCByZWplY3QpOyB9OyB9XG4gIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpZiAoZ1tuXSkgeyBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyBpZiAoZikgaVtuXSA9IGYoaVtuXSk7IH0gfVxuICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XG4gIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxuICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XG4gIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cbiAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0RlbGVnYXRvcihvKSB7XG4gIHZhciBpLCBwO1xuICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xuICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaVtuXSA9IG9bbl0gPyBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBmYWxzZSB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XG4gIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG4gIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XG4gIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcbiAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxuICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xuICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxuICByZXR1cm4gY29va2VkO1xufTtcblxudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgb1tcImRlZmF1bHRcIl0gPSB2O1xufTtcblxudmFyIG93bktleXMgPSBmdW5jdGlvbihvKSB7XG4gIG93bktleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiAobykge1xuICAgIHZhciBhciA9IFtdO1xuICAgIGZvciAodmFyIGsgaW4gbykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBrKSkgYXJbYXIubGVuZ3RoXSA9IGs7XG4gICAgcmV0dXJuIGFyO1xuICB9O1xuICByZXR1cm4gb3duS2V5cyhvKTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydFN0YXIobW9kKSB7XG4gIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrID0gb3duS2V5cyhtb2QpLCBpID0gMDsgaSA8IGsubGVuZ3RoOyBpKyspIGlmIChrW2ldICE9PSBcImRlZmF1bHRcIikgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrW2ldKTtcbiAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0RGVmYXVsdChtb2QpIHtcbiAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBkZWZhdWx0OiBtb2QgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRHZXQocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XG4gIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xuICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEluKHN0YXRlLCByZWNlaXZlcikge1xuICBpZiAocmVjZWl2ZXIgPT09IG51bGwgfHwgKHR5cGVvZiByZWNlaXZlciAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgcmVjZWl2ZXIgIT09IFwiZnVuY3Rpb25cIikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgdXNlICdpbicgb3BlcmF0b3Igb24gbm9uLW9iamVjdFwiKTtcbiAgcmV0dXJuIHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgPT09IHN0YXRlIDogc3RhdGUuaGFzKHJlY2VpdmVyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fYWRkRGlzcG9zYWJsZVJlc291cmNlKGVudiwgdmFsdWUsIGFzeW5jKSB7XG4gIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdCBleHBlY3RlZC5cIik7XG4gICAgdmFyIGRpc3Bvc2UsIGlubmVyO1xuICAgIGlmIChhc3luYykge1xuICAgICAgaWYgKCFTeW1ib2wuYXN5bmNEaXNwb3NlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jRGlzcG9zZSBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgICBkaXNwb3NlID0gdmFsdWVbU3ltYm9sLmFzeW5jRGlzcG9zZV07XG4gICAgfVxuICAgIGlmIChkaXNwb3NlID09PSB2b2lkIDApIHtcbiAgICAgIGlmICghU3ltYm9sLmRpc3Bvc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuZGlzcG9zZSBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgICBkaXNwb3NlID0gdmFsdWVbU3ltYm9sLmRpc3Bvc2VdO1xuICAgICAgaWYgKGFzeW5jKSBpbm5lciA9IGRpc3Bvc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZGlzcG9zZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IG5vdCBkaXNwb3NhYmxlLlwiKTtcbiAgICBpZiAoaW5uZXIpIGRpc3Bvc2UgPSBmdW5jdGlvbigpIHsgdHJ5IHsgaW5uZXIuY2FsbCh0aGlzKTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7IH0gfTtcbiAgICBlbnYuc3RhY2sucHVzaCh7IHZhbHVlOiB2YWx1ZSwgZGlzcG9zZTogZGlzcG9zZSwgYXN5bmM6IGFzeW5jIH0pO1xuICB9XG4gIGVsc2UgaWYgKGFzeW5jKSB7XG4gICAgZW52LnN0YWNrLnB1c2goeyBhc3luYzogdHJ1ZSB9KTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbnZhciBfU3VwcHJlc3NlZEVycm9yID0gdHlwZW9mIFN1cHByZXNzZWRFcnJvciA9PT0gXCJmdW5jdGlvblwiID8gU3VwcHJlc3NlZEVycm9yIDogZnVuY3Rpb24gKGVycm9yLCBzdXBwcmVzc2VkLCBtZXNzYWdlKSB7XG4gIHZhciBlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICByZXR1cm4gZS5uYW1lID0gXCJTdXBwcmVzc2VkRXJyb3JcIiwgZS5lcnJvciA9IGVycm9yLCBlLnN1cHByZXNzZWQgPSBzdXBwcmVzc2VkLCBlO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fZGlzcG9zZVJlc291cmNlcyhlbnYpIHtcbiAgZnVuY3Rpb24gZmFpbChlKSB7XG4gICAgZW52LmVycm9yID0gZW52Lmhhc0Vycm9yID8gbmV3IF9TdXBwcmVzc2VkRXJyb3IoZSwgZW52LmVycm9yLCBcIkFuIGVycm9yIHdhcyBzdXBwcmVzc2VkIGR1cmluZyBkaXNwb3NhbC5cIikgOiBlO1xuICAgIGVudi5oYXNFcnJvciA9IHRydWU7XG4gIH1cbiAgdmFyIHIsIHMgPSAwO1xuICBmdW5jdGlvbiBuZXh0KCkge1xuICAgIHdoaWxlIChyID0gZW52LnN0YWNrLnBvcCgpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIXIuYXN5bmMgJiYgcyA9PT0gMSkgcmV0dXJuIHMgPSAwLCBlbnYuc3RhY2sucHVzaChyKSwgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihuZXh0KTtcbiAgICAgICAgaWYgKHIuZGlzcG9zZSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSByLmRpc3Bvc2UuY2FsbChyLnZhbHVlKTtcbiAgICAgICAgICBpZiAoci5hc3luYykgcmV0dXJuIHMgfD0gMiwgUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCkudGhlbihuZXh0LCBmdW5jdGlvbihlKSB7IGZhaWwoZSk7IHJldHVybiBuZXh0KCk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgcyB8PSAxO1xuICAgICAgfVxuICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgZmFpbChlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHMgPT09IDEpIHJldHVybiBlbnYuaGFzRXJyb3IgPyBQcm9taXNlLnJlamVjdChlbnYuZXJyb3IpIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgaWYgKGVudi5oYXNFcnJvcikgdGhyb3cgZW52LmVycm9yO1xuICB9XG4gIHJldHVybiBuZXh0KCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3Jld3JpdGVSZWxhdGl2ZUltcG9ydEV4dGVuc2lvbihwYXRoLCBwcmVzZXJ2ZUpzeCkge1xuICBpZiAodHlwZW9mIHBhdGggPT09IFwic3RyaW5nXCIgJiYgL15cXC5cXC4/XFwvLy50ZXN0KHBhdGgpKSB7XG4gICAgICByZXR1cm4gcGF0aC5yZXBsYWNlKC9cXC4odHN4KSR8KCg/OlxcLmQpPykoKD86XFwuW14uL10rPyk/KVxcLihbY21dPyl0cyQvaSwgZnVuY3Rpb24gKG0sIHRzeCwgZCwgZXh0LCBjbSkge1xuICAgICAgICAgIHJldHVybiB0c3ggPyBwcmVzZXJ2ZUpzeCA/IFwiLmpzeFwiIDogXCIuanNcIiA6IGQgJiYgKCFleHQgfHwgIWNtKSA/IG0gOiAoZCArIGV4dCArIFwiLlwiICsgY20udG9Mb3dlckNhc2UoKSArIFwianNcIik7XG4gICAgICB9KTtcbiAgfVxuICByZXR1cm4gcGF0aDtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBfX2V4dGVuZHMsXG4gIF9fYXNzaWduLFxuICBfX3Jlc3QsXG4gIF9fZGVjb3JhdGUsXG4gIF9fcGFyYW0sXG4gIF9fZXNEZWNvcmF0ZSxcbiAgX19ydW5Jbml0aWFsaXplcnMsXG4gIF9fcHJvcEtleSxcbiAgX19zZXRGdW5jdGlvbk5hbWUsXG4gIF9fbWV0YWRhdGEsXG4gIF9fYXdhaXRlcixcbiAgX19nZW5lcmF0b3IsXG4gIF9fY3JlYXRlQmluZGluZyxcbiAgX19leHBvcnRTdGFyLFxuICBfX3ZhbHVlcyxcbiAgX19yZWFkLFxuICBfX3NwcmVhZCxcbiAgX19zcHJlYWRBcnJheXMsXG4gIF9fc3ByZWFkQXJyYXksXG4gIF9fYXdhaXQsXG4gIF9fYXN5bmNHZW5lcmF0b3IsXG4gIF9fYXN5bmNEZWxlZ2F0b3IsXG4gIF9fYXN5bmNWYWx1ZXMsXG4gIF9fbWFrZVRlbXBsYXRlT2JqZWN0LFxuICBfX2ltcG9ydFN0YXIsXG4gIF9faW1wb3J0RGVmYXVsdCxcbiAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCxcbiAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCxcbiAgX19jbGFzc1ByaXZhdGVGaWVsZEluLFxuICBfX2FkZERpc3Bvc2FibGVSZXNvdXJjZSxcbiAgX19kaXNwb3NlUmVzb3VyY2VzLFxuICBfX3Jld3JpdGVSZWxhdGl2ZUltcG9ydEV4dGVuc2lvbixcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/antd-img-crop/node_modules/tslib/tslib.es6.mjs\n");

/***/ })

};
;